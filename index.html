<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D GLB Viewer + WebXR AR | index.html</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f17" />
  <meta name="description" content="Standalone Three.js GLB model viewer with OrbitControls and WebXR AR mode. Mobile-first, deploy-ready for GitHub Pages." />
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#101828;
      --muted:#98a2b3;
      --text:#eef2ff;
      --primary:#48aaff;
      --primary-press:#2f90e3;
      --accent:#22c55e;
      --danger:#ef4444;
      --card:#0f172a;
      --shadow: rgba(0,0,0,.35);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:500 15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif}
    #app{
      display:grid;
      grid-template-rows:auto 1fr auto;
      height:100%;
      max-width:900px;
      margin:0 auto;
      gap:10px;
      padding:10px 10px calc(env(safe-area-inset-bottom) + 10px);
    }
    header{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius);
      padding:10px;
      position:sticky; top:0;
      z-index:3;
    }
    .bar{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .brand{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:50%;background:var(--primary);box-shadow:0 0 20px var(--primary)}
    .brand h1{font-size:16px;margin:0;font-weight:700;letter-spacing:.3px}
    .support-note{color:var(--muted);font-size:12px}
    .support-note strong{color:#cbd5e1;font-weight:700}

    .selector{
      display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-top:10px;
    }
    .model-btn{
      appearance:none; border:1px solid rgba(255,255,255,.08); background:var(--card);
      color:var(--text); border-radius:10px; padding:10px 6px; text-align:center;
      cursor:pointer; outline:none; position:relative; transition:transform .08s ease, border-color .15s ease, box-shadow .15s ease;
      box-shadow:0 6px 16px -8px var(--shadow) inset, 0 1px 0 0 rgba(255,255,255,.04);
      user-select:none;
    }
    .model-btn:active{transform:translateY(1px)}
    .model-btn.selected{border-color:var(--primary); box-shadow:0 0 0 2px rgba(72,170,255,.15)}
    .model-name{display:block; font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .icon{
      display:flex; align-items:center; justify-content:center;
      width:100%; height:36px; border-radius:8px; background:linear-gradient(180deg,#172036,#0d1422);
      border:1px solid rgba(255,255,255,.06);
    }
    .icon svg{opacity:.9}

    main{
      position:relative; display:grid; grid-template-rows:1fr auto; gap:10px; min-height:0;
    }
    #viewer{
      position:relative; min-height:320px; flex:1; background:linear-gradient(180deg,#0a0f1a,#0b1220);
      border:1px solid rgba(255,255,255,.08); border-radius:var(--radius); overflow:hidden;
    }
    canvas{display:block; width:100%; height:100%}
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
    }
    .spinner{
      width:42px; height:42px; border:4px solid rgba(255,255,255,.18); border-top-color:var(--primary); border-radius:50%; animation:spin 1s linear infinite; box-shadow:0 0 24px rgba(72,170,255,.35);
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .toast{
      position:absolute; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(15,23,42,.9); backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,.1); color:#e2e8f0; font-size:13px;
      padding:8px 12px; border-radius:10px; pointer-events:auto; z-index:4;
      display:none;
    }
    .toast.show{display:flex; gap:8px; align-items:center}
    .toast.error{border-color:rgba(239,68,68,.5); color:#fecaca}
    .toast .dot{width:8px;height:8px}

    .controls{
      display:flex; gap:10px; justify-content:space-between; align-items:center; flex-wrap:wrap;
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.08); border-radius:var(--radius); padding:10px;
    }
    .btn{
      appearance:none; border:none; border-radius:12px; padding:12px 14px; font-weight:700; letter-spacing:.2px; cursor:pointer; transition:transform .06s ease, box-shadow .15s ease, background .15s ease;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn.primary{background:var(--primary); color:#041019; box-shadow:0 8px 24px -10px rgba(72,170,255,.8)}
    .btn.primary:active{transform:translateY(1px); background:var(--primary-press)}
    .btn.secondary{background:#0b1426; color:#dbeafe; border:1px solid rgba(255,255,255,.08)}
    .btn.secondary:active{transform:translateY(1px)}
    .btn[disabled]{opacity:.5; pointer-events:none}
    .hint{color:var(--muted); font-size:12px}
    .grow{flex:1}
    .right{display:flex; gap:8px}

    footer{
      color:var(--muted); font-size:12px; text-align:center; padding-top:4px;
    }

    /* Mobile-first tweaks */
    @media (max-width:480px){
      .selector{grid-template-columns:repeat(5,1fr)}
    }
    @media (min-width:481px){
      .selector{grid-template-columns:repeat(8,1fr)}
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="bar">
        <div class="brand">
          <div class="dot"></div>
          <h1>GLB Viewer + AR</h1>
        </div>
        <div class="support-note">
          <strong>Tip:</strong> Works best on Chrome or Edge for Android.
        </div>
      </div>

      <!-- Model selection grid -->
      <div class="selector" id="modelSelector" aria-label="Model selection">
        <!-- The 5 placeholders below assume GLB files in ./models/ -->
        <!-- Place actual files at: /models/car.glb, /models/robot.glb, /models/chair.glb, /models/building.glb, /models/character.glb -->
      </div>
    </header>

    <main>
      <div id="viewer" role="region" aria-label="3D viewer">
        <div class="overlay" id="loadingOverlay" aria-live="polite" style="display:none">
          <div class="spinner" aria-hidden="true"></div>
        </div>
        <div class="toast" id="toast" role="alert"></div>
        <!-- Three.js canvas is injected here -->
      </div>

      <div class="controls">
        <div class="grow hint">
          â€¢ Drag to rotate â€¢ Pinch to zoom â€¢ Two-finger drag to pan â€¢ Reset to refocus
        </div>
        <div class="right">
          <button class="btn secondary" id="resetBtn" type="button" title="Reset view">âŸ² Reset View</button>
          <button class="btn primary" id="arBtn" type="button" title="Enter AR" disabled>ðŸ“± Enter AR</button>
        </div>
      </div>
      <div class="hint">
        AR instructions: Move your phone to scan your space until the reticle appears, then tap to place the model. Pinch to scale and drag to rotate.
      </div>
    </main>

    <footer>
      Place your GLB files in the models/ folder. This single-file app is deploy-ready on GitHub Pages and will cache assets for offline reuse.
    </footer>
  </div>

  <script>
    // --- Bootloader: cache and load required Three.js scripts from cdnjs for offline reuse ---
    // This keeps the app single-file and still "uses Three.js from https://cdnjs.cloudflare.com".
    (function(){
      const CDN = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r152';
      const scripts = [
        `${CDN}/three.min.js`,
        `${CDN}/examples/js/controls/OrbitControls.min.js`,
        `${CDN}/examples/js/loaders/GLTFLoader.min.js`
      ];

      const cacheName = 'threejs-cdn-cache-v1';
      const loaded = [];

      function loadScriptFromText(text){
        return new Promise((resolve,reject)=>{
          const blob = new Blob([text], {type:'application/javascript'});
          const url = URL.createObjectURL(blob);
          const s = document.createElement('script');
          s.src = url;
          s.onload = ()=>{ URL.revokeObjectURL(url); resolve(); };
          s.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
          document.head.appendChild(s);
        });
      }

      async function getScriptText(url){
        try{
          const c = await caches.open(cacheName);
          let res = await c.match(url, {ignoreVary:true, ignoreSearch:true});
          if(!res){
            res = await fetch(url, {mode:'cors', credentials:'omit', cache:'no-cache'});
            if(!res.ok) throw new Error('HTTP '+res.status);
            // store clone
            try { await c.put(url, res.clone()); } catch(e){ /* cache may fail silently */ }
          }
          return await res.text();
        }catch(err){
          // Last resort: try direct network fetch (may be offline)
          const res = await fetch(url);
          if(!res.ok) throw new Error('HTTP '+res.status);
          return await res.text();
        }
      }

      async function boot(){
        for(const url of scripts){
          const text = await getScriptText(url);
          await loadScriptFromText(text);
          loaded.push(url);
        }
        // kick off app after scripts are injected
        window.__three_ready__ = true;
        document.dispatchEvent(new Event('three-ready'));
      }

      // Warm up cache hint (non-blocking)
      caches && caches.open(cacheName).then(()=>{}).catch(()=>{});

      boot().catch(err=>{
        const t = document.getElementById('toast');
        t.className = 'toast error show';
        t.textContent = 'Failed to load 3D engine. Check your connection and reload.';
        console.error('Boot error:', err);
      });
    })();
  </script>

  <script>
  // ---- Application Code (runs after Three.js is ready) ----
  document.addEventListener('three-ready', () => {
    // Basic capability checks
    if (!window.THREE || !THREE.WEBGL.isWebGLAvailable()) {
      showToast('Your browser does not support WebGL required for 3D viewing.', true);
      return;
    }

    // UI elements
    const viewerEl = document.getElementById('viewer');
    const overlayEl = document.getElementById('loadingOverlay');
    const toastEl = document.getElementById('toast');
    const arBtn = document.getElementById('arBtn');
    const resetBtn = document.getElementById('resetBtn');
    const selectorEl = document.getElementById('modelSelector');

    // Models placeholder list (relative to this HTML)
    const MODELS = [
      { id:'car',       name:'car.glb',       path:'models/car.glb' },
      { id:'robot',     name:'robot.glb',     path:'models/robot.glb' },
      { id:'chair',     name:'chair.glb',     path:'models/chair.glb' },
      { id:'building',  name:'building.glb',  path:'models/building.glb' },
      { id:'character', name:'character.glb', path:'models/character.glb' },
    ];

    // Build the selection grid
    MODELS.forEach((m, idx) => {
      const btn = document.createElement('button');
      btn.className = 'model-btn';
      btn.type = 'button';
      btn.dataset.path = m.path;
      btn.title = m.name;
      btn.innerHTML = `
        <div class="icon">${getSVGIcon(idx)}</div>
        <span class="model-name">${m.name}</span>
      `;
      btn.addEventListener('click', () => selectModel(m, btn));
      selectorEl.appendChild(btn);
    });

    // Three.js core
    let renderer, scene, camera, controls, pmrem, clock;
    let modelRoot = new THREE.Group(); // container for current model
    let currentModelInfo = null;
    let defaultCamState = null;
    let rafId = null;

    initThree();
    startViewerLoop();

    // AR state
    let arSession = null;
    let xrRefSpace = null;
    let hitTestSource = null;
    let viewerSpace = null;
    let reticle = null;
    let placedAnchor = null;
    let arScale = 1;
    const supportsXR = !!(navigator.xr && 'isSessionSupported' in navigator.xr);

    // UI events
    arBtn.addEventListener('click', onEnterAR);
    resetBtn.addEventListener('click', resetView);

    // Select default model (first)
    const firstBtn = selectorEl.querySelector('.model-btn');
    if (firstBtn) firstBtn.click();

    // ---------- Functions ----------
    function initThree(){
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(viewerEl.clientWidth, viewerEl.clientHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.shadowMap.enabled = true;
      viewerEl.appendChild(renderer.domElement);

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1220);

      // Camera
      const fov = 50;
      const aspect = viewerEl.clientWidth / Math.max(1, viewerEl.clientHeight);
      camera = new THREE.PerspectiveCamera(fov, aspect, 0.01, 1000);
      camera.position.set(2.2, 1.4, 2.2);
      defaultCamState = { pos: camera.position.clone(), target: new THREE.Vector3(0,0,0) };

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 0.2;
      controls.maxDistance = 20;
      controls.target.copy(defaultCamState.target);

      // Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.6);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 7);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024, 1024);
      scene.add(dir);

      // Subtle environment for PBR
      pmrem = new THREE.PMREMGenerator(renderer);

      // Ground (for view, hidden in AR)
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(200,200),
        new THREE.ShadowMaterial({ opacity: 0.15 })
      );
      ground.name = 'ground';
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -0.0001;
      ground.receiveShadow = true;
      scene.add(ground);

      // Model root
      scene.add(modelRoot);

      // Clock
      clock = new THREE.Clock();

      // Resize
      window.addEventListener('resize', onResize, { passive:true });

      // Toast
      if (!supportsXR) {
        showToast('AR not available on this device/browser. 3D viewer is fully supported.');
      }
    }

    function onResize(){
      const w = viewerEl.clientWidth, h = viewerEl.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / Math.max(1, h);
      camera.updateProjectionMatrix();
    }

    function startViewerLoop(){
      cancelAnimationFrame(rafId);
      const loop = () => {
        rafId = requestAnimationFrame(loop);
        controls.update();
        renderer.render(scene, camera);
      };
      loop();
    }

    function stopViewerLoop(){
      cancelAnimationFrame(rafId);
    }

    function setLoading(v){
      overlayEl.style.display = v ? 'flex' : 'none';
    }

    function showToast(msg, isError=false, timeout=3500){
      toastEl.textContent = msg;
      toastEl.className = 'toast show' + (isError ? ' error' : '');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>{ toastEl.className = 'toast'; }, timeout);
    }

    async function selectModel(m, btnEl){
      // Update selection UI
      selectorEl.querySelectorAll('.model-btn').forEach(b => b.classList.remove('selected'));
      btnEl.classList.add('selected');

      // Load and display model
      setLoading(true);
      arBtn.disabled = true;
      currentModelInfo = m;

      // Remove previous model
      modelRoot.clear();

      try{
        const gltf = await loadGLBWithCache(m.path);
        const root = gltf.scene || gltf.scenes?.[0];
        if (!root) throw new Error('No scene in GLB');

        // Normalize transforms
        root.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
            if (obj.material && 'envMapIntensity' in obj.material) {
              obj.material.envMapIntensity = 1.0;
            }
          }
        });

        // Auto-center and scale
        const bbox = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); bbox.getSize(size);
        const center = new THREE.Vector3(); bbox.getCenter(center);
        root.position.sub(center); // center at origin

        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const targetSize = 1.2; // meters for framing in viewer
        const scale = targetSize / maxDim;
        root.scale.setScalar(scale);

        modelRoot.add(root);
        frameModel(root);

        setLoading(false);
        if (supportsXR) arBtn.disabled = false;
        showToast(`Loaded: ${m.name}`);
      }catch(err){
        console.error(err);
        setLoading(false);
        arBtn.disabled = true;
        showToast(`Failed to load ${m.name}. Ensure the file exists in /models/`, true, 5000);
      }
    }

    function resetView(){
      // Reset camera and controls to default or refit current model
      const model = modelRoot.children[0];
      if (model) {
        frameModel(model, true);
      } else {
        camera.position.copy(defaultCamState.pos);
        controls.target.copy(defaultCamState.target);
        controls.update();
      }
      showToast('View reset');
    }

    function frameModel(object3D, smooth=false){
      const box = new THREE.Box3().setFromObject(object3D);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fitDistance = (maxDim / (2*Math.tan(THREE.MathUtils.degToRad(camera.fov/2)))) * 1.3;

      const dir = new THREE.Vector3(1, 0.6, 1).normalize();
      const newPos = center.clone().add(dir.multiplyScalar(fitDistance));

      if (smooth) {
        // simple smooth transition
        const from = camera.position.clone();
        const to = newPos.clone();
        let t = 0, d = 0.25; // seconds
        const start = performance.now();
        (function anim(){
          const now = performance.now();
          t = Math.min(1, (now - start) / (d*1000));
          camera.position.lerpVectors(from, to, t);
          controls.target.lerp(center, t);
          controls.update();
          renderer.render(scene, camera);
          if (t < 1) requestAnimationFrame(anim);
        })();
      } else {
        camera.position.copy(newPos);
        controls.target.copy(center);
        controls.update();
      }
    }

    // ------- GLB loading with offline caching (no Service Worker required) -------
    // Uses Cache Storage to store GLB blobs and then loads via blob: URLs.
    async function loadGLBWithCache(url){
      const manager = new THREE.LoadingManager();
      const loader = new THREE.GLTFLoader(manager);

      // Fetch from cache or network as Blob
      const blob = await getAssetBlob(url);
      // Create a blob URL for GLTFLoader to load
      const blobUrl = URL.createObjectURL(blob);

      return new Promise((resolve, reject) => {
        loader.load(blobUrl, (gltf) => {
          URL.revokeObjectURL(blobUrl);
          resolve(gltf);
        }, onProgress, (err) => {
          URL.revokeObjectURL(blobUrl);
          reject(err);
        });
      });

      function onProgress(ev){
        if (ev.lengthComputable) {
          const p = Math.round((ev.loaded / ev.total) * 100);
          // could update a progress bar if desired
        }
      }
    }

    async function getAssetBlob(url){
      const cacheName = 'asset-cache-v1';
      const c = await caches.open(cacheName);
      let res = await c.match(url, { ignoreVary:true, ignoreSearch:true });
      if (!res) {
        // Try to fetch and then cache
        res = await fetch(url);
        if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
        try { await c.put(url, res.clone()); } catch(e) {}
      }
      return await res.blob();
    }

    // -------------------- AR Mode (WebXR: hit-test placement) --------------------
    async function onEnterAR(){
      if (!supportsXR) {
        showToast('WebXR not available on this device.', true);
        return;
      }
      try{
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          showToast('AR session not supported. Update your browser/device.', true);
          return;
        }
      }catch(e){
        showToast('Unable to start AR. Check permissions or browser settings.', true);
        return;
      }

      // Prepare AR button state
      arBtn.disabled = true;

      // Create reticle if not exist
      if (!reticle) {
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI/2),
          new THREE.MeshBasicMaterial({ color: 0x48aaff, transparent:true, opacity:0.85 })
        );
        reticle.matrixAutoUpdate = false;
      }

      // Hide ground in AR
      const ground = scene.getObjectByName('ground');
      if (ground) ground.visible = false;

      // Enable XR
      renderer.xr.enabled = true;

      // Request session with required features
      try{
        arSession = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test', 'local-floor', 'dom-overlay'],
          domOverlay: { root: document.body },
          optionalFeatures: ['anchors']
        });
      }catch(e){
        showToast('AR session request was denied.', true);
        renderer.xr.enabled = false;
        if (ground) ground.visible = true;
        arBtn.disabled = false;
        return;
      }

      // Setup XR reference spaces
      xrRefSpace = await arSession.requestReferenceSpace('local-floor');
      viewerSpace = await arSession.requestReferenceSpace('viewer');

      // Create hit test source
      const hitSource = await arSession.requestHitTestSource({ space: viewerSpace });
      hitTestSource = hitSource;

      // Add reticle to scene
      scene.add(reticle);

      // Input handling: place model on select (tap)
      const onSelect = async (ev) => {
        const frame = ev.frame;
        const hitResults = frame.getHitTestResults(hitTestSource);
        if (!hitResults || hitResults.length === 0) return;
        const hit = hitResults[0];
        const pose = hit.getPose(xrRefSpace);
        if (!pose) return;

        // Place the model at the hit pose
        const model = modelRoot.children[0];
        if (!model) return;

        // Optional: try to create an anchor for stability
        if (hit.createAnchor) {
          try{
            const anchor = await hit.createAnchor();
            placedAnchor = anchor;
            const anchorGroup = new THREE.Group();
            scene.add(anchorGroup);
            // anchor's coordinate system updates per frame
            anchor.context = { group: anchorGroup, model };
            anchorGroup.add(model);
            model.position.set(0,0,0);
            model.rotation.set(0,0,0);
            model.scale.setScalar(arScale);
            showToast('Model placed. Tap again to move.');
          }catch(e){
            // Fallback: place without anchor
            placeWithoutAnchor(model, pose.transform);
          }
        } else {
          placeWithoutAnchor(model, pose.transform);
        }
      };

      function placeWithoutAnchor(model, transform){
        const m = new THREE.Matrix4().fromArray(transform.matrix);
        model.applyMatrix4(new THREE.Matrix4().copy(m));
        model.position.setFromMatrixPosition(m);
        // Keep upright orientation (optional)
        const eul = new THREE.Euler().setFromRotationMatrix(m, 'YXZ');
        model.rotation.set(0, eul.y, 0);
        model.scale.setScalar(arScale);
        showToast('Model placed. Tap again to move.');
      }

      // Controller for select events
      const controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Allow pinch/drag gestures via CSS overlay (dom-overlay is enabled)
      enableARGestures();

      // When session ends, cleanup
      arSession.addEventListener('end', () => {
        renderer.setAnimationLoop(null);
        renderer.xr.enabled = false;
        hitTestSource = null;
        viewerSpace = null;
        xrRefSpace = null;
        arSession = null;
        if (reticle) { scene.remove(reticle); }
        // Return model back to scene root if it was parented
        const model = modelRoot.children[0];
        if (model && model.parent !== modelRoot) {
          model.parent.remove(model);
          modelRoot.add(model);
        }
        const ground = scene.getObjectByName('ground');
        if (ground) ground.visible = true;
        startViewerLoop(); // back to normal rendering
        arBtn.disabled = false;
        showToast('AR session ended');
      });

      // Start AR animation loop
      renderer.xr.setReferenceSpaceType('local-floor');
      await renderer.xr.setSession(arSession);

      renderer.setAnimationLoop((time, frame) => {
        // Update anchors
        if (arSession && arSession.trackedAnchors) {
          arSession.trackedAnchors.forEach(anchor => {
            if (!anchor.context) return;
            const pose = frame.getPose(anchor.anchorSpace, xrRefSpace);
            if (pose) {
              anchor.context.group.matrix.fromArray(pose.transform.matrix);
              anchor.context.group.matrix.decompose(anchor.context.group.position, anchor.context.group.quaternion, anchor.context.group.scale);
            }
          });
        }

        // Hit test to position reticle
        if (frame && hitTestSource) {
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length) {
            const hit = hits[0];
            const pose = hit.getPose(xrRefSpace);
            if (pose) {
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            }
          } else {
            reticle.visible = false;
          }
        }

        renderer.render(scene, camera);
      });

      showToast('Move your phone to find a surface, then tap to place.');
    }

    function enableARGestures(){
      // Simple pinch to scale and drag to rotate on the placed model
      let touching = false;
      let lastDist = 0;
      let lastX = 0;
      const el = renderer.domElement;

      el.addEventListener('touchstart', (e) => {
        if (!arSession) return;
        touching = true;
        if (e.touches.length === 2) {
          lastDist = touchDistance(e.touches[0], e.touches[1]);
        } else if (e.touches.length === 1) {
          lastX = e.touches[0].clientX;
        }
      }, {passive:true});

      el.addEventListener('touchmove', (e) => {
        if (!arSession) return;
        const model = modelRoot.children[0];
        if (!model) return;
        if (e.touches.length === 2) {
          const dist = touchDistance(e.touches[0], e.touches[1]);
          const delta = dist - lastDist;
          lastDist = dist;
          const s = THREE.MathUtils.clamp(model.scale.x + delta * 0.001, 0.05, 5);
          arScale = s;
          model.scale.setScalar(arScale);
        } else if (e.touches.length === 1) {
          const dx = e.touches[0].clientX - lastX;
          lastX = e.touches[0].clientX;
          model.rotation.y += dx * 0.005;
        }
      }, {passive:true});

      el.addEventListener('touchend', () => {
        touching = false;
      }, {passive:true});

      function touchDistance(a,b){
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy);
      }
    }

    // ---------- Small helpers ----------
    function getSVGIcon(i){
      const icons = [
        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M3 13l9-9 9 9v7a2 2 0 0 1-2 2h-5v-7H10v7H5a2 2 0 0 1-2-2v-7z" stroke="#9bbcf5" stroke-width="1.6"/></svg>',
        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><rect x="7" y="3" width="10" height="6" rx="1.5" stroke="#9bbcf5" stroke-width="1.6"/><rect x="5" y="9" width="14" height="12" rx="2" stroke="#9bbcf5" stroke-width="1.6"/></svg>',
        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M7 15h10l2 5H5l2-5z" stroke="#9bbcf5" stroke-width="1.6"/><rect x="8" y="4" width="8" height="8" rx="2" stroke="#9bbcf5" stroke-width="1.6"/></svg>',
        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 20h16v-9l-8-5-8 5v9z" stroke="#9bbcf5" stroke-width="1.6"/><path d="M12 6v14" stroke="#9bbcf5" stroke-width="1.6"/></svg>',
        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="7" r="3" stroke="#9bbcf5" stroke-width="1.6"/><path d="M6 21v-2a6 6 0 0 1 12 0v2" stroke="#9bbcf5" stroke-width="1.6"/></svg>',
      ];
      return icons[i % icons.length];
    }

  });
  </script>

  <!--
    Deployment notes:
    - File name must be index.html (this file).
    - Place your 3D models here: /models/car.glb, /models/robot.glb, /models/chair.glb, /models/building.glb, /models/character.glb
    - Host on GitHub Pages (HTTPS). The app uses cdnjs for Three.js and caches assets for offline reuse.
    - AR requires a compatible Android device + Chrome/Edge with WebXR enabled. Gracefully degrades if unavailable.
  -->
</body>
</html>
