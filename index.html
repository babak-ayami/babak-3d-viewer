<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>3D GLB Model Viewer + AR (WebXR)</title>
  <meta name="description" content="Standalone Three.js GLB viewer with gallery, OrbitControls, and WebXR AR mode. Optimized for Android mobile. Deploy-ready for GitHub Pages." />
  <link rel="manifest" href="data:application/manifest+json,{\"name\":\"GLB Viewer AR\",\"short_name\":\"GLB-AR\",\"start_url\":\".\",\"display\":\"standalone\",\"background_color\":\"#0b0f19\",\"theme_color\":\"#0b0f19\"}" />
  <meta name="theme-color" content="#0b0f19" />
  <style>
    :root {
      --bg: #0b0f19;
      --panel: rgba(255,255,255,0.06);
      --panel-strong: rgba(255,255,255,0.12);
      --text: #e7ecf2;
      --muted: #a6b0bf;
      --accent: #7bd88f;
      --accent-2: #7aa2f7;
      --danger: #ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; }
    a { color: inherit; text-decoration: none; }
    button { cursor: pointer; }

    .app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100dvh; /* better on mobile */
      max-width: 100vw;
    }

    /* Top bar */
    header {
      position: sticky; top: 0; z-index: 10;
      backdrop-filter: saturate(1.2) blur(10px);
      background: linear-gradient(180deg, rgba(15,20,32,.9), rgba(15,20,32,.6));
      border-bottom: 1px solid var(--panel-strong);
    }
    .bar {
      display: grid; gap: 10px; align-items: center;
      grid-template-columns: 1fr auto; padding: 12px clamp(12px, 3vw, 24px);
    }
    .brand { font-weight: 700; letter-spacing: .2px; }
    .sub { color: var(--muted); font-size: 12px; }

    .selectors {
      display: grid; gap: 8px; grid-template-columns: 1fr auto; align-items: center;
    }
    .grid {
      display: grid; gap: 8px; grid-template-columns: repeat(5, minmax(60px, 1fr));
      padding: 10px; border-top: 1px dashed var(--panel-strong);
    }
    .model-btn {
      border: 1px solid var(--panel-strong);
      background: var(--panel);
      color: var(--text);
      border-radius: calc(var(--radius) - 8px);
      padding: 10px 8px; text-align: center; font-size: 12px; line-height: 1.1; width: 100%;
      transition: transform .2s ease, background .2s ease, border-color .2s ease;
    }
    .model-btn.active { border-color: var(--accent); background: rgba(123,216,143,.12); }
    .model-btn:active { transform: scale(.98); }

    select.model-select {
      appearance: none; width: 100%;
      border: 1px solid var(--panel-strong);
      background: var(--panel);
      color: var(--text); padding: 10px 12px; border-radius: 12px;
    }

    /* Viewer */
    .viewer {
      position: relative; min-height: 50vh; height: 100%;
      display: grid; place-items: center;
      padding: 8px 8px 0 8px;
    }
    canvas { display: block; width: 100% !important; height: 100% !important; border-radius: var(--radius); box-shadow: var(--shadow); background: #0c0f17; }

    .hud {
      position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: 1fr auto; padding: 10px;
    }
    .hud .top { display: flex; gap: 8px; }
    .hud .bottom { display: grid; gap: 8px; }

    .pill {
      pointer-events: auto; border: 1px solid var(--panel-strong); background: var(--panel);
      padding: 10px 14px; border-radius: 999px; font-size: 14px; display: inline-flex; align-items: center; gap: 8px;
      backdrop-filter: blur(8px);
    }
    .primary { background: linear-gradient(180deg, rgba(123,162,247,.25), rgba(123,162,247,.18)); border-color: rgba(123,162,247,.5); }
    .success { background: linear-gradient(180deg, rgba(123,216,143,.25), rgba(123,216,143,.18)); border-color: rgba(123,216,143,.5); }
    .danger { background: linear-gradient(180deg, rgba(255,107,107,.25), rgba(255,107,107,.18)); border-color: rgba(255,107,107,.5); }

    .row { display: flex; gap: 8px; flex-wrap: wrap; }

    .progress {
      width: 100%; height: 4px; border-radius: 999px; background: rgba(255,255,255,.08); overflow: hidden; box-shadow: inset 0 1px 2px rgba(0,0,0,.35);
    }
    .progress > span { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent-2), var(--accent)); transition: width .2s ease; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; background: radial-gradient(1200px 600px at 50% -10%, rgba(123,162,247,.12), transparent 60%), linear-gradient(180deg, rgba(11,15,25,.9), rgba(11,15,25,.6));
      z-index: 5; backdrop-filter: blur(3px);
    }
    .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,.15); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .msg { text-align: center; color: var(--muted); font-size: 14px; }
    .msg strong { color: var(--text); }

    footer {
      font-size: 12px; color: var(--muted); padding: 8px 14px; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid var(--panel-strong);
    }

    /* Reticle (AR) */
    .reticle-hint {
      position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
      background: var(--panel); border: 1px solid var(--panel-strong); border-radius: 999px; padding: 8px 12px; font-size: 13px;
      opacity: 0; transition: opacity .3s ease; pointer-events: none;
    }

    @media (max-width: 520px) {
      .grid { grid-template-columns: repeat(3, 1fr); }
      .bar { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="bar">
        <div>
          <div class="brand">GLB Model Viewer <span class="sub">Â· Three.js + WebXR AR</span></div>
        </div>
        <div class="selectors">
          <select class="model-select" id="modelSelect" aria-label="Choose a model">
            <!-- Update file names if you change models. Place actual .glb files into ./models/ -->
            <option value="chair.glb" selected>Chair</option>
            <option value="table.glb">Table</option>
            <option value="lamp.glb">Lamp</option>
            <option value="sofa.glb">Sofa</option>
            <option value="plant.glb">Plant</option>
          </select>
          <button class="pill" id="resetBtn" title="Reset Camera">Reset View</button>
        </div>
        <div class="grid" id="modelGrid" aria-label="Model quick selection">
          <!-- Tappable quick-select buttons; keep labels short. -->
          <button class="model-btn active" data-file="chair.glb">Chair</button>
          <button class="model-btn" data-file="table.glb">Table</button>
          <button class="model-btn" data-file="lamp.glb">Lamp</button>
          <button class="model-btn" data-file="sofa.glb">Sofa</button>
          <button class="model-btn" data-file="plant.glb">Plant</button>
        </div>
      </div>
    </header>

    <main class="viewer">
      <div id="threeMount"></div>
      <div class="hud">
        <div class="top row">
          <div class="pill" id="statusPill">Ready</div>
        </div>
        <div class="bottom">
          <div class="progress" aria-label="Loading progress"><span id="progressBar"></span></div>
          <div class="row">
            <button class="pill primary" id="enterArBtn" hidden>Enter AR</button>
            <button class="pill" id="helpBtn" title="AR Instructions">AR Help</button>
          </div>
        </div>
      </div>
      <div class="overlay" id="loadingOverlay" aria-live="polite">
        <div class="spinner" aria-hidden="true"></div>
      </div>
      <div class="reticle-hint" id="reticleHint">Move your phone to scan a surface. Tap to place.</div>
    </main>

    <footer>
      <div>Place your GLB files in <code>/models/</code> next to this file. Works on Android Chrome/Edge with WebXR.</div>
      <div id="supportMsg"></div>
    </footer>
  </div>

  <!-- Three.js + JSM via cdnjs (kept as the only external dependency). -->
  <script type="module">
    // CDN URLs (pinned versions for stability). Update if needed.
    const CDNS = {
      three: 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.module.min.js',
      controls: 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/examples/jsm/controls/OrbitControls.min.js',
      gltf: 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/examples/jsm/loaders/GLTFLoader.min.js'
    };

    // --- Lazy import modules ---
    const [{ WebGLRenderer, Scene, Color, PerspectiveCamera, sRGBEncoding, ACESFilmicToneMapping, DirectionalLight, AmbientLight, GridHelper, Group, Vector3, Clock },
           { OrbitControls },
           { GLTFLoader }]
      = await Promise.all([
        import(CDNS.three),
        import(CDNS.controls),
        import(CDNS.gltf)
      ]).then(([THREE, controls, loaders]) => [
        THREE,
        controls,
        loaders
      ]);

    // --- DOM refs ---
    const mount = document.getElementById('threeMount');
    const statusPill = document.getElementById('statusPill');
    const progressBar = document.getElementById('progressBar');
    const enterArBtn = document.getElementById('enterArBtn');
    const helpBtn = document.getElementById('helpBtn');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const reticleHint = document.getElementById('reticleHint');
    const modelSelect = document.getElementById('modelSelect');
    const modelGrid = document.getElementById('modelGrid');
    const resetBtn = document.getElementById('resetBtn');
    const supportMsg = document.getElementById('supportMsg');

    // --- Renderer & scene setup ---
    const renderer = new WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(mount.clientWidth, Math.max(320, mount.clientHeight));
    renderer.outputEncoding = sRGBEncoding;
    renderer.toneMapping = ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.xr.enabled = true; // needed for WebXR
    mount.appendChild(renderer.domElement);

    const scene = new Scene();
    scene.background = new Color(0x0c0f17);

    const camera = new PerspectiveCamera(55, mount.clientWidth / Math.max(320, mount.clientHeight), 0.01, 100);

    const initialCamPos = new Vector3(1.8, 1.2, 2.4);
    camera.position.copy(initialCamPos);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0.8, 0);

    // Lighting
    const hemi = new AmbientLight(0xffffff, 0.7);
    scene.add(hemi);
    const dir1 = new DirectionalLight(0xffffff, 1.0); dir1.position.set(5, 8, 3); dir1.castShadow = false; scene.add(dir1);
    const dir2 = new DirectionalLight(0xffffff, 0.6); dir2.position.set(-4, 6, -2); scene.add(dir2);
    const grid = new GridHelper(10, 10, 0x334, 0x223); grid.position.y = 0; grid.material.opacity = 0.15; grid.material.transparent = true; scene.add(grid);

    // Resize handling
    const onResize = () => {
      const w = mount.clientWidth; const h = Math.max(320, mount.clientHeight);
      renderer.setSize(w, h);
      camera.aspect = w / h; camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', onResize);

    // Loading manager for progress
    const manager = new (await import(CDNS.three)).LoadingManager();
    manager.onStart = () => { setLoading(true, 'Loadingâ¦'); updateProgress(0); };
    manager.onProgress = (_url, itemsLoaded, itemsTotal) => {
      const pct = Math.round((itemsLoaded / itemsTotal) * 100);
      updateProgress(pct);
    };
    manager.onLoad = () => { setLoading(false); updateProgress(100); enterArBtn.hidden = false; };
    manager.onError = (url) => { notify(`Error loading: ${url}`, true); };

    const loader = new GLTFLoader(manager);

    // Current model holder
    const modelRoot = new Group();
    scene.add(modelRoot);

    async function loadModel(file) {
      const url = `models/${file}`; // Files must exist at /models/<name>.glb
      // Clean up previous
      while (modelRoot.children.length) {
        const c = modelRoot.children.pop();
        c.traverse?.(obj => {
          if (obj.isMesh) { obj.geometry?.dispose?.(); Array.isArray(obj.material) ? obj.material.forEach(m=>m.dispose?.()) : obj.material?.dispose?.(); }
          if (obj.dispose) obj.dispose();
        });
      }
      try {
        setLoading(true, `Loading ${file}â¦`);
        const gltf = await loader.loadAsync(url);
        const obj = gltf.scene;
        // Normalize model scale & position for consistent view
        obj.updateMatrixWorld(true);
        // Compute bounding box
        const THREE = await import(CDNS.three);
        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const scale = 1.2 / maxDim; // fit into ~1.2m cube
        obj.scale.setScalar(scale);
        obj.position.sub(center.multiplyScalar(scale));
        obj.position.y -= box.min.y * scale; // ground it

        modelRoot.add(obj);
        focusForView(maxDim * scale);
        notify(`Loaded: ${file}`);
        enterArBtn.hidden = false; // show AR once loaded
      } catch (e) {
        console.error(e);
        notify('Failed to load model. See console.', true);
      } finally {
        setLoading(false);
      }
    }

    function focusForView(modelSize=1) {
      const dist = modelSize * 3.0 + 1.2;
      const target = new Vector3(0, modelSize * 0.6, 0);
      controls.target.copy(target);
      camera.position.copy(target.clone().add(new Vector3(dist*0.7, dist*0.5, dist)));
      controls.update();
    }

    function resetView() {
      camera.position.copy(initialCamPos);
      controls.target.set(0, 0.8, 0);
      controls.update();
    }

    resetBtn.addEventListener('click', resetView);

    // UI hookups: select & grid
    modelSelect.addEventListener('change', (e) => {
      const file = e.target.value;
      setActiveGrid(file); loadModel(file);
    });
    modelGrid.addEventListener('click', (e) => {
      const btn = e.target.closest('.model-btn'); if (!btn) return;
      const file = btn.dataset.file; modelSelect.value = file;
      setActiveGrid(file); loadModel(file);
    });
    function setActiveGrid(file) {
      for (const b of modelGrid.querySelectorAll('.model-btn')) b.classList.toggle('active', b.dataset.file === file);
    }

    // Status helpers
    function setLoading(isLoading, msg='') {
      loadingOverlay.style.display = isLoading ? 'grid' : 'none';
      if (msg) statusPill.textContent = msg; else statusPill.textContent = isLoading ? 'Loadingâ¦' : 'Ready';
    }
    function updateProgress(pct) { progressBar.style.width = `${Math.max(0, Math.min(100, pct))}%`; }
    function notify(text, isError=false) {
      statusPill.textContent = text;
      statusPill.classList.toggle('danger', isError);
      if (isError) console.warn(text);
    }

    // Basic animation loop
    const clock = new Clock();
    renderer.setAnimationLoop(() => {
      const dt = clock.getDelta();
      controls.update();
      renderer.render(scene, camera);
    });

    // Initial load
    loadModel('chair.glb');

    // --- WebXR AR implementation (without Three's ARButton helper) ---
    const isSecure = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';

    async function getXRSupport() {
      if (!isSecure) return { ok:false, reason: 'HTTPS is required for WebXR.' };
      if (!('xr' in navigator)) return { ok:false, reason: 'WebXR not available in this browser.' };
      const supported = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
      return supported ? { ok:true } : { ok:false, reason:'AR mode is not supported on this device.' };
    }

    (async () => {
      const res = await getXRSupport();
      supportMsg.textContent = res.ok ? 'WebXR AR supported' : `No AR: ${res.reason}`;
      if (!res.ok) enterArBtn.disabled = true; // keep hidden until model loads, but also disabled if unsupported
    })();

    let xrSession = null, xrRefSpace = null, xrHitTestSource = null, reticle = null, placed = false;

    // Create reticle mesh
    async function ensureReticle() {
      if (reticle) return reticle;
      const THREE = await import(CDNS.three);
      const geom = new THREE.RingGeometry(0.12, 0.14, 32).rotateX(-Math.PI/2);
      const mat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.85 });
      reticle = new THREE.Mesh(geom, mat);
      reticle.matrixAutoUpdate = false; reticle.visible = false;
      // Use a separate scene for AR overlay? We'll just add to main scene when entering AR.
      return reticle;
    }

    async function enterAR() {
      const sup = await getXRSupport(); if (!sup.ok) { notify(`Cannot enter AR: ${sup.reason}`, true); return; }
      try {
        xrSession = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test', 'local-floor'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });

        renderer.xr.setReferenceSpaceType('local-floor');
        await renderer.xr.setSession(xrSession);
        xrRefSpace = await xrSession.requestReferenceSpace('local-floor');

        const viewerSpace = await xrSession.requestReferenceSpace('viewer');
        xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

        (await ensureReticle()).visible = false; scene.add(reticle);
        reticleHint.style.opacity = 1;
        placed = false;

        xrSession.addEventListener('end', onXRSessionEnded);
        xrSession.addEventListener('select', onSelect); // tap to place

        // AR render loop uses renderer.setAnimationLoop already; augment with hit-test per-frame
        renderer.setAnimationLoop(onXRFrame);
      } catch (e) {
        console.error(e);
        notify('Failed to start AR session. See console.', true);
      }
    }

    function onXRSessionEnded() {
      renderer.setAnimationLoop(() => { controls.update(); renderer.render(scene, camera); });
      if (reticle) reticle.visible = false;
      reticleHint.style.opacity = 0;
      xrSession = null; xrRefSpace = null; xrHitTestSource = null;
    }

    function onSelect() {
      if (!reticle?.visible) return; // only place when we have a hit
      // Place the modelRoot at the reticle pose
      const m = new (renderer.xr.getCamera().matrix.constructor)(); // DOMMatrixReadOnly -> THREE.Matrix4 compatible via elements
      // Instead of creating a new Matrix4 from DOMMatrix, we use Matrix4.fromArray
      const THREE = renderer.constructor; // not ideal; we'll import explicitly below
    }

    // We'll implement select using cached pose from last frame
    let lastHitPose = null;

    function placeAtPose() {
      if (!lastHitPose) return;
      const p = lastHitPose.transform.position;
      const q = lastHitPose.transform.orientation;
      modelRoot.position.set(p.x, p.y, p.z);
      modelRoot.quaternion.set(q.x, q.y, q.z, q.w);
      // Keep model roughly same scale (already normalized), ensure on floor
      modelRoot.updateMatrixWorld(true);
      placed = true;
      reticleHint.style.opacity = 0;
    }

    function onXRFrame(time, frame) {
      const session = frame.session;
      const refSpace = xrRefSpace;
      const pose = frame.getViewerPose(refSpace);

      if (xrHitTestSource && pose) {
        const hits = frame.getHitTestResults(xrHitTestSource);
        if (hits.length > 0) {
          const hit = hits[0];
          lastHitPose = hit.getPose(refSpace);
          if (reticle) {
            reticle.visible = true;
            // reticle.matrix is THREE.Matrix4; set from XRRigidTransform
            const m = new (await import(CDNS.three)).Matrix4();
            m.fromArray(lastHitPose.transform.matrix);
            reticle.matrix.copy(m);
          }
        } else {
          if (reticle) reticle.visible = false;
        }
      }

      renderer.render(scene, camera);
    }

    // Because onSelect needs frame context, attach via DOM event on canvas for simplicity
    renderer.domElement.addEventListener('click', () => { if (xrSession) { placeAtPose(); } });

    enterArBtn.addEventListener('click', enterAR);

    // Help / Instructions
    helpBtn.addEventListener('click', () => {
      alert(
`AR Instructions:\n\n1) Tap \"Enter AR\". If prompted, allow camera access.\n2) Move your phone left/right and up/down to let it find a surface.\n   A circular reticle will appear when a surface is detected.\n3) Tap once to place the model at the reticle.\n4) Move closer/farther to view. Two-finger pinch to scale the page (if supported).\n5) Tap outside the canvas or press the back button to exit AR.\n\nTip: Good lighting and textured surfaces improve tracking stability.`);
    });

    // --- Service Worker for offline (after first load) ---
    // Caches this HTML, CDN modules, and any models you load under /models/.
    const SW_CODE = `
      const NAME = 'glb-ar-v1';
      const CDN = [
        '${CDNS.three}',
        '${CDNS.controls}',
        '${CDNS.gltf}'
      ];
      self.addEventListener('install', event => {
        self.skipWaiting();
        event.waitUntil(caches.open(NAME).then(cache => cache.addAll(['./', ...CDN])));
      });
      self.addEventListener('activate', event => {
        event.waitUntil((async () => {
          const keys = await caches.keys();
          await Promise.all(keys.filter(k => k !== NAME).map(k => caches.delete(k)));
          self.clients.claim();
        })());
      });
      self.addEventListener('fetch', event => {
        const url = new URL(event.request.url);
        // Cache-first for same-origin, CDN, and model glb files
        if (url.origin === location.origin || url.hostname.includes('cdnjs.cloudflare.com')) {
          event.respondWith((async () => {
            const cache = await caches.open(NAME);
            const cached = await cache.match(event.request);
            if (cached) return cached;
            try {
              const resp = await fetch(event.request);
              if (resp && resp.status === 200 && (url.origin === location.origin || url.hostname.includes('cdnjs'))) {
                cache.put(event.request, resp.clone());
              }
              return resp;
            } catch (err) {
              return cached || Response.error();
            }
          })());
        }
      });
    `;

    if ('serviceWorker' in navigator) {
      const blob = new Blob([SW_CODE], { type: 'text/javascript' });
      const swUrl = URL.createObjectURL(blob);
      try { await navigator.serviceWorker.register(swUrl); } catch (e) { console.warn('SW registration failed', e); }
    }

  </script>

  <!-- Fallback message for non-module browsers -->
  <noscript>
    <div style="padding:16px;color:#fff;background:#c0392b">This app requires JavaScript to run.</div>
  </noscript>

  <!--
  ============================
  Deployment & Assets Notes
  ============================
  â¢ Save this file as `index.html` at your GitHub Pages site root.
  â¢ Create a folder named `models/` next to this file and add your GLB files:
      models/chair.glb
      models/table.glb
      models/lamp.glb
      models/sofa.glb
      models/plant.glb
    (You can change namesâupdate the <select> and quick buttons accordingly.)
  â¢ The service worker will cache this page, the cdnjs modules, and any models you load, so it works offline after first load.
  â¢ AR requires HTTPS and a modern Android browser that supports WebXR (Chrome/Edge). If not supported, the Enter AR button will be disabled and a message shown in the footer.
  -->
</body>
</html>
